Lemma check_headers_and_state_vars_intermediate:
  forall s1 s2 header_list state_var_list f,
  eval_smt_bool (check_headers_and_state_vars s1 s2 header_list state_var_list) f = false ->
  eval_smt_bool (List.fold_right (fun h acc => SmtBoolAnd acc (SmtBoolEq (header_map SmtArithExpr s1 h) (header_map SmtArithExpr s2 h))) 
                   (List.fold_right (fun sv acc => SmtBoolAnd acc (SmtBoolEq (state_var_map SmtArithExpr s1 sv) (state_var_map SmtArithExpr s2 sv))) 
                                    SmtTrue state_var_list) header_list) f = true.
Proof.
  intros s1 s2 header_list state_var_list f H.
  unfold check_headers_and_state_vars in H.
  simpl in H.
  (* The negation of the conjunction is true if at least one of the components is false *)
  apply Bool.negb_false_iff in H.
  assumption.
Qed.

Lemma SmtBoolConjunction_concat_true:
  forall l1 l2 f,
  eval_smt_bool (List.fold_right SmtBoolAnd SmtTrue (l1 ++ l2)) f = true ->
  forallb (fun e => eval_smt_bool e f) l1 = true /\
  forallb (fun e => eval_smt_bool e f) l2 = true.
Proof.
Admitted.

Lemma check_headers_and_state_vars_intermediate2:
  forall s1 s2 header_list state_var_list f,
  eval_smt_bool (check_headers_and_state_vars s1 s2 header_list state_var_list) f = false ->
  eval_smt_bool (List.fold_right (fun h acc => SmtBoolAnd acc (SmtBoolEq (header_map SmtArithExpr s1 h) (header_map SmtArithExpr s2 h))) SmtTrue header_list) f = true /\
  eval_smt_bool (List.fold_right (fun sv acc => SmtBoolAnd acc (SmtBoolEq (state_var_map SmtArithExpr s1 sv) (state_var_map SmtArithExpr s2 sv))) SmtTrue state_var_list) f = true.
Proof.
  intros s1 s2 header_list state_var_list f H.
  apply check_headers_and_state_vars_intermediate in H.
  (* Now we have a conjunction of two parts, one for headers and one for state vars *)
  split.
  - 

  (* The negation of the conjunction is true if at least one of the components is false *)
  apply Bool.negb_false_iff in H.
  assumption.
Qed.

Lemma SmtBoolConjunction_true:
  forall l f,
  eval_smt_bool (List.fold_right SmtBoolAnd SmtTrue l) f = true ->
  forallb (fun e => eval_smt_bool e f) l = true.
Proof.
  intros l f H.
  induction l as [|h t IH].
  - simpl in H. reflexivity.
  - simpl in H.
    simpl. apply andb_true_iff. split.
    apply andb_true_iff in H. apply H.
    apply andb_true_iff in H.
    destruct H as [H1 H2].
    apply IH in H2.
    assumption.
Qed.

